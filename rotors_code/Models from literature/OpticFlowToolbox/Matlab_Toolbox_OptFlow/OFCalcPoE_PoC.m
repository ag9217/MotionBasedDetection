function [PoE,PoC] = OFCalcPoE_PoC( sp, hof, vof, t )
%OFCALCPOE_POC returns the points which are PoE or PoC,
%       derived by the Optic Flow.
%   CAUTION: This works only for SamplePoints generated by OFGenerateSp!
%   if there are PoE or/and PoC which are not on the border of the 
%   Optic Flow, these Points will be returned.
%Input:
%   sp - Sx2 matrix azimuth(0 - 2*pi), zenith(pi/2 - -pi/2
%       baisicly an spherical coordinate system but with GEOGRAPHICAL
%       LATITUDE (elevation / altitude)
%       [pi/2 0]= left, [3*pi/2 0]= right, [0 pi/2]= top, [0 -pi/2]= bottom
%
%   hof - txS matrix with the horizontal coordinates of the shifted
%       samplepoints
%
%   vof - txS matrix with the vertical coordinates of the shifted
%       samplepoints
%
%   t - trajectory position of the Optoc Flow
%
%Output:
%   PoE - nx3 matrix with the first two spheric coordinates which are assumed
%       to be PoE's. these coordinates are relative to observer, 
%       where the observer would see the PoE (with [0,0]=viewing direction)
%       the third is the frame number (trajectory step) at which the PoE's
%       where found.
%   PoC - mx3 matrix with the first two spheric coordinates which are assumed
%       to be PoC's. these coordinates are relative to observer, 
%       where the observer would see the PoC (with [0,0]=viewing direction)
%       the third is the frame number (trajectory step) at which the PoC's
%       where found.
%
%   see also OFGenerateSp, OFCalcOpticFlow
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	Copyright (C) 2009-2014 J.P. Lindemann, C. Strub
%		
%   This file is part of the ivtools.
%   https://opensource.cit-ec.de/projects/ivtools
%
%   the Optic-Flow toolbox is free software: you can redistribute it and/or modify
%    it under the terms of the GNU General Public License as published by
%    the Free Software Foundation, either version 3 of the License, or
%    (at your option) any later version.
%
%   the Optic-Flow toolbox is distributed in the hope that it will be useful,
%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%    GNU General Public License for more details.
%
%    You should have received a copy of the GNU General Public License
%    along with Foobar.  If not, see <http://www.gnu.org/licenses/>.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



    if(t>size(hof,1)||t<0)
        error('chosen trajectory position t is out of range');
    end
    
    x=sp(:,1)';
    y=sp(:,2)';
    
    u = zeros( 1 , length(x));
    v = zeros( 1 , length(x));
    
    %compute the flowVector
    for k=1:length(x),
        u(k)=-x(k)+hof(t,k);
        if(u(k)>pi),
            u(k)=-2*pi+u(k);
        end
        v(k)=-y(k)+vof(t,k);
    end
    %------------------------

    
    
    n=length(x);
    
    %find the dimensions of the sp-matrices
    for i=1:n,
        if(y(i)~=y(1))
            col=i-1;
            row=n/(i-1);
            if(row~=floor(row))
                error('sp not generated with OFGenerateSp');
            end
            break;
        end
    end
    
    %transform optic flow from lists to matrices
    X=reshape(x,col,row)';
    Y=reshape(y,col,row)';    
     
    %for testing reason
%     U=reshape(hof(t,:)',col,row)';    
%     temp=reshape(u,col,row)';
%     [X(1,:)',U(1,:)',temp(1,:)']
    
    for m=1:size(u,2),
        leng=sqrt(u(m)^2+v(m)^2);
        if(leng~=0)
            u(m)=u(m)/leng;
            v(m)=v(m)/leng;
        end
    end    
    
    U=reshape(u,col,row)';
    V=reshape(v,col,row)';
    div=divergence(X,Y,U,V);
    
    DIVERGENCE_TOLERANCE=0.1*min(row,col); % divergence must be bigger
    
    PoE_index=[];
    PoC_index=[];
    leng_y=size(div,1);
    leng_x=size(div,2);

    %check if divergence is big and if all sorrounding vectors point
    %away/towards position
    for m=2:leng_y-1,
        for k=2:leng_x-1,
            %PoE?
            if(div(m,k)>DIVERGENCE_TOLERANCE)
                if(area(U,V,k,m,true))
                    PoE_index=[PoE_index,leng_x*(m-1)+k];
                end
            %PoC?
            elseif(div(m,k)<-DIVERGENCE_TOLERANCE)
                if(area(U,V,k,m,false))
                    PoC_index=[PoC_index,leng_x*(m-1)+k];
                end
            end
        end 
    end

    % find the coresponding trajectory-shifted samplepoint:
    avPoE=[];
    avPoC=[];
    for k=1:length(PoE_index),
        avPoE(k,:)=sp(PoE_index(k),:);
    end
    for k=1:length(PoC_index),
        avPoC(k,:)=sp(PoC_index(k),:);       
    end
    
    %testing outputs:
%     avPoE
%     avPoC
   
    %combine near Points of Exp/Contr to one point
    avDist_x=(max(sp(:,1))-min(sp(:,1)))/leng_x;
    avDist_y=(max(pi/2+sp(:,2))-min(pi/2+sp(:,2)))/leng_y;
    PoE=[];
    PoC=[];
    if(~isempty(avPoE))
        PoE=combine(avPoE,avDist_x,avDist_y);
    end
    if(~isempty(avPoC))
        PoC=combine(avPoC,avDist_x,avDist_y);
    end
    
    %add frame index to PoE's and PoC's
    if(~isempty(PoE))
        PoE(:,3)=t;
    end
    if(~isempty(PoC))
        PoC(:,3)=t;    
    end
    
    %plot the normalized FlowField
    %figure('Name','Normalized Optic_flow'), quiver(X,Y,U,V);
    %figure('Name','divergence'), surf(X,Y,div), colormap(bone);

end

%combines near ponts to one point (PoE/PoC)
function PoE_PoC = combine(avPoE_PoC,avDist_x,avDist_y)
    PoE_PoC=[];
    DEVIATION=1.5; % deviation tollerance, sholdnt need to be variated
    k=1;
    while(~isempty(avPoE_PoC))
        PoE_PoC_temp=[];
        cent=centroid(avPoE_PoC);

        %do this as long as u find an vector that is "not near enough"
        % to the centroid in avPoE_PoC. if you find one, move him to PoE_PoC_temp and
        % try again. when no vector is found->cent is the 1. PoE.
        % then set avPoE_PoC=PoE_PoC_temp and repeat the whole proscedure if avPoE_PoC is
        % not empty.
        foundException=true;
        while(foundException)
            foundException=false;            
            % check the azimuth deviation form centroid
            if(((max(avPoE_PoC(:,1))-cent(:,1)<DEVIATION*avDist_x)||...
                (2*pi-(max(avPoE_PoC(:,1))-cent(:,1))<DEVIATION*avDist_x))&&...
                    ((cent(:,1)-min(avPoE_PoC(:,1))<DEVIATION*avDist_x)||...
                    (2*pi-(cent(:,1)-min(avPoE_PoC(:,1)))<DEVIATION*avDist_x)))
                % check the elevation deviation form centroid
                if(max(pi/2+avPoE_PoC(:,2))-(pi/2+cent(:,2))<DEVIATION*avDist_y)&&...
                        (pi/2+cent(:,2)-(pi/2+min(avPoE_PoC(:,2)))<DEVIATION*avDist_y)
                    PoE_PoC(k,:)=cent;
                    k=k+1;
                else % one point with too big elevation-deviation has been found
                    %move point with min from avPoE_PoC to PoE_PoC_temp
                    %and recompute the sum
                    exc=min(avPoE_PoC(:,2));
                    siz=size(avPoE_PoC,1);
                    m=1;
                    while(m<=siz)
                        if(avPoE_PoC(m,2)==exc)
                            PoE_PoC_temp(end+1,:)=avPoE_PoC(m,:);
                            avPoE_PoC(m,:)=[];
                            siz=siz-1;
                        end
                        m=m+1;
                    end
                    cent=centroid(avPoE_PoC);
                    %do loop again
                    foundException=true;
                end
            else % one Point with too big azimuth derivation has been found
                %move point with min from avPoE_PoC to PoE_PoC_temp
                %and recompute the sum
                
                if((max(avPoE_PoC(:,1))-cent(:,1)<DEVIATION*avDist_x)||...
                    (2*pi-(max(avPoE_PoC(:,1))-cent(:,1))<DEVIATION*avDist_x))
                    exc=min(avPoE_PoC(:,1));
                else
                    exc=max(avPoE_PoC(:,1));
                end
                siz=size(avPoE_PoC,1);
                m=1;
                while(m<=siz)
                    if(avPoE_PoC(m,1)==exc)
                        PoE_PoC_temp(end+1,:)=avPoE_PoC(m,:);
                        avPoE_PoC(m,:)=[];
                        siz=siz-1;
                    end
                    m=m+1;
                end
                cent=centroid(avPoE_PoC);
                % do loop again
                foundException=true;
            end
            
        end %while(foundExcepition)
        %one PoE has been found
        avPoE_PoC=PoE_PoC_temp;
    end %while(~isempty(avPoE_PoC))
    %finished with PoE!
end


% aproximizes the centroid of a bunch of Points on a unit-sphere
function sum= centroid(avPoE_PoC)
    sum=0;
    for k=1:size(avPoE_PoC,1),
        sum=sum+OFSubroutineSpToVector(avPoE_PoC(k,:));
    end
    sum=OFSubroutineVectorToSp(sum);
end

%checks whether the sorrounding vectors point away from position x,y
function area= area(X,Y,x,y,expand)
    area=true;
    %--- 9 points in area -------------------------
    k=1;
    while(k<=9)
        if(k==5)%skip midle position
            k=6;
        end        
        area=area_subr(X,Y,x,y,k,k,expand);
        if(area==false)
            break;
        end
        k=k+1;
    end
    %--- 6 points in area --------------------------
    %top 6
    if(area==false)
        area=true;
        for k=1:6,
            if k<4,
                addr=k;
            else % shift middle addr-row to bottom row
                addr=k+3;
            end
            area=area_subr(X,Y,x,y,k,addr,expand);
            if(area==false)
                break;
            end
        end
    end
    %botom 6
    if(area==false)
        area=true;
        for k=4:9,
            if k<7, % shift middle addr-row to top row
                addr=k-3;
            else
                addr=k;
            end
            area=area_subr(X,Y,x,y,k,addr,expand);
            if(area==false)
                break;
            end
        end
    end
    %left 6
    if(area==false)
        area=true;
        k=1;
        while(k<9)
            if(mod(k,3)==0) %skip right collum
                k=k+1;
            end            
            if(k==2||k==5||k==8) % shift middle addr-collum to right
                addr=k+1;
            else
                addr=k;
            end                        
            area=area_subr(X,Y,x,y,k,addr,expand);
            if(area==false)
                break;
            end
            k=k+1;
        end
    end
    %right 6
    if(area==false)
        area=true;
        k=1;
        while(k<=9)
            if(k==1||k==4||k==7) % skip left collum
                k=k+1;
            end            
            if(k==2||k==5||k==8) % shift middle addr-collum to left
                addr=k-1;
            else
                addr=k;
            end           
            area=area_subr(X,Y,x,y,k,addr,expand);
            if(area==false)
                break;
            end
            k=k+1;
        end
    end
    
    %--- 4 points in area ------------
    %topleft
    if(area==false)
        area=area_subr(X,Y,x,y,1,1,expand); 
        if(area==true)
            area=area_subr(X,Y,x,y,2,3,expand);
        end
        if(area==true)
            area=area_subr(X,Y,x,y,4,7,expand);
        end
        if(area==true)
            area=area_subr(X,Y,x,y,5,9,expand);
        end
    end
    
    %topright
    if(area==false)
        area=area_subr(X,Y,x,y,2,1,expand);
        if(area==true)
            area=area_subr(X,Y,x,y,3,3,expand);
        end
        if(area==true)
            area=area_subr(X,Y,x,y,5,7,expand);
        end
        if(area==true)
            area=area_subr(X,Y,x,y,6,9,expand);
        end
    end
    
    %botomleft
    if(area==false)
        area=area_subr(X,Y,x,y,4,1,expand);
        if(area==true)
            area=area_subr(X,Y,x,y,5,3,expand);
        end
        if(area==true)
            area=area_subr(X,Y,x,y,7,7,expand);
        end
        if(area==true)
            area=area_subr(X,Y,x,y,8,9,expand);
        end
    end
    %botomright
    if(area==false)
        area=area_subr(X,Y,x,y,5,1,expand);
        if(area==true)
            area=area_subr(X,Y,x,y,6,3,expand);
        end
        if(area==true)
            area=area_subr(X,Y,x,y,8,7,expand);
        end
        if(area==true)
            area=area_subr(X,Y,x,y,9,9,expand);
        end
    end
end

% subroutine for area.
% computes wheter the vector at index from (x,y) points in direction addr
% under contraint expansion
function direction = area_subr(X, Y, x, y, index, addr, expand)
    sur_x=[-1,0,1,-1,0,1,-1,0,1];
    sur_y=[-1,-1,-1,0,0,0,1,1,1];
    direction=true;
    x_temp=x+sur_x(index);
    y_temp=y+sur_y(index);
           
    %surounding vector point away from (x,y)?
    if(expand==true)
        if(X(y_temp,x_temp)*sur_x(addr)<0 || Y(y_temp,x_temp)*-sur_y(addr)<0)
            direction=false;
        end
    else
        if(X(y_temp,x_temp)*sur_x(addr)>0 || Y(y_temp,x_temp)*-sur_y(addr)>0)
            direction=false;
        end
    end

end
